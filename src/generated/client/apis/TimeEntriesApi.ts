/* tslint:disable */
/* eslint-disable */
// @ts-nocheck
/**
 * Vehicle Management Services (management)
 * Vehicle Management Services (management)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    TimeEntry,
    TimeEntryFromJSON,
    TimeEntryToJSON,
} from '../models';

export interface CreateEmployeeTimeEntryRequest {
    timeEntry: TimeEntry;
    employeeId: string;
}

export interface DeleteEmployeeTimeEntryRequest {
    employeeId: string;
    timeEntryId: string;
}

export interface FindEmployeeTimeEntryRequest {
    employeeId: string;
    timeEntryId: string;
}

export interface ListEmployeeTimeEntriesRequest {
    employeeId: string;
    start?: Date;
    end?: Date;
    first?: number;
    max?: number;
}

export interface UpdateEmployeeTimeEntryRequest {
    timeEntry: TimeEntry;
    employeeId: string;
    timeEntryId: string;
}

/**
 * 
 */
export class TimeEntriesApi extends runtime.BaseAPI {
    /**
     * Creates Employees Time Entry.  Attempt to create new time entry should fail if:   1) New time entry does not have endTime but there is already one time entry without endTime for the same employee. This is because time entries without endTime are considered to be running timers and only one is allowed at a time.   2) If time new entry intersects with an existing time entry. 
     * Create Employees Time Entry.
     */
    async createEmployeeTimeEntryRaw(requestParameters: CreateEmployeeTimeEntryRequest): Promise<runtime.ApiResponse<TimeEntry>> {
        if (requestParameters.timeEntry === null || requestParameters.timeEntry === undefined) {
            throw new runtime.RequiredError('timeEntry','Required parameter requestParameters.timeEntry was null or undefined when calling createEmployeeTimeEntry.');
        }
        if (requestParameters.employeeId === null || requestParameters.employeeId === undefined) {
            throw new runtime.RequiredError('employeeId','Required parameter requestParameters.employeeId was null or undefined when calling createEmployeeTimeEntry.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["manager", "driver", "employee"]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user-management/v1/employees/{employeeId}/timeEntries`.replace(`{${"employeeId"}}`, encodeURIComponent(String(requestParameters.employeeId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TimeEntryToJSON(requestParameters.timeEntry),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => TimeEntryFromJSON(jsonValue));
    }
    /**
     * Creates Employees Time Entry.  Attempt to create new time entry should fail if:   1) New time entry does not have endTime but there is already one time entry without endTime for the same employee. This is because time entries without endTime are considered to be running timers and only one is allowed at a time.   2) If time new entry intersects with an existing time entry. 
     * Create Employees Time Entry.
     */
    async createEmployeeTimeEntry(requestParameters: CreateEmployeeTimeEntryRequest): Promise<TimeEntry> {
        const response = await this.createEmployeeTimeEntryRaw(requestParameters);
        return await response.value();
    }
    /**
     * Creates Employees Time Entry.  Attempt to create new time entry should fail if:   1) New time entry does not have endTime but there is already one time entry without endTime for the same employee. This is because time entries without endTime are considered to be running timers and only one is allowed at a time.   2) If time new entry intersects with an existing time entry. 
     * Create Employees Time Entry.
     */
    async createEmployeeTimeEntryWithHeaders(requestParameters: CreateEmployeeTimeEntryRequest): Promise<[ TimeEntry, Headers ]> {
        const response = await this.createEmployeeTimeEntryRaw(requestParameters);
        const value = await response.value(); 
        return [ value, response.raw.headers ];
    }
    /**
     * Deletes Employee\'s Time Entry. Only accessible by managers.
     * Delete Employee\'s Time Entry.
     */
    async deleteEmployeeTimeEntryRaw(requestParameters: DeleteEmployeeTimeEntryRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.employeeId === null || requestParameters.employeeId === undefined) {
            throw new runtime.RequiredError('employeeId','Required parameter requestParameters.employeeId was null or undefined when calling deleteEmployeeTimeEntry.');
        }
        if (requestParameters.timeEntryId === null || requestParameters.timeEntryId === undefined) {
            throw new runtime.RequiredError('timeEntryId','Required parameter requestParameters.timeEntryId was null or undefined when calling deleteEmployeeTimeEntry.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["manager"]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user-management/v1/employees/{employeeId}/timeEntries/{timeEntryId}`.replace(`{${"employeeId"}}`, encodeURIComponent(String(requestParameters.employeeId))).replace(`{${"timeEntryId"}}`, encodeURIComponent(String(requestParameters.timeEntryId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Deletes Employee\'s Time Entry. Only accessible by managers.
     * Delete Employee\'s Time Entry.
     */
    async deleteEmployeeTimeEntry(requestParameters: DeleteEmployeeTimeEntryRequest): Promise<void> {
        await this.deleteEmployeeTimeEntryRaw(requestParameters);
    }
    /**
     * Deletes Employee\'s Time Entry. Only accessible by managers.
     * Delete Employee\'s Time Entry.
     */
    async deleteEmployeeTimeEntryWithHeaders(requestParameters: DeleteEmployeeTimeEntryRequest): Promise<Headers> {
        const response = await this.deleteEmployeeTimeEntryRaw(requestParameters);
        return response.raw.headers;
    }
    /**
     * Finds an employee\'s time entry by id.
     * Find an employee\'s time entry.
     */
    async findEmployeeTimeEntryRaw(requestParameters: FindEmployeeTimeEntryRequest): Promise<runtime.ApiResponse<TimeEntry>> {
        if (requestParameters.employeeId === null || requestParameters.employeeId === undefined) {
            throw new runtime.RequiredError('employeeId','Required parameter requestParameters.employeeId was null or undefined when calling findEmployeeTimeEntry.');
        }
        if (requestParameters.timeEntryId === null || requestParameters.timeEntryId === undefined) {
            throw new runtime.RequiredError('timeEntryId','Required parameter requestParameters.timeEntryId was null or undefined when calling findEmployeeTimeEntry.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["manager", "driver", "employee"]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user-management/v1/employees/{employeeId}/timeEntries/{timeEntryId}`.replace(`{${"employeeId"}}`, encodeURIComponent(String(requestParameters.employeeId))).replace(`{${"timeEntryId"}}`, encodeURIComponent(String(requestParameters.timeEntryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => TimeEntryFromJSON(jsonValue));
    }
    /**
     * Finds an employee\'s time entry by id.
     * Find an employee\'s time entry.
     */
    async findEmployeeTimeEntry(requestParameters: FindEmployeeTimeEntryRequest): Promise<TimeEntry> {
        const response = await this.findEmployeeTimeEntryRaw(requestParameters);
        return await response.value();
    }
    /**
     * Finds an employee\'s time entry by id.
     * Find an employee\'s time entry.
     */
    async findEmployeeTimeEntryWithHeaders(requestParameters: FindEmployeeTimeEntryRequest): Promise<[ TimeEntry, Headers ]> {
        const response = await this.findEmployeeTimeEntryRaw(requestParameters);
        const value = await response.value(); 
        return [ value, response.raw.headers ];
    }
    /**
     * Lists Employees Time Entries. Sort by start time, latest first.
     * List Employees Time Entries.
     */
    async listEmployeeTimeEntriesRaw(requestParameters: ListEmployeeTimeEntriesRequest): Promise<runtime.ApiResponse<Array<TimeEntry>>> {
        if (requestParameters.employeeId === null || requestParameters.employeeId === undefined) {
            throw new runtime.RequiredError('employeeId','Required parameter requestParameters.employeeId was null or undefined when calling listEmployeeTimeEntries.');
        }
        const queryParameters: any = {};
        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString();
        }
        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString();
        }
        if (requestParameters.first !== undefined) {
            queryParameters['first'] = requestParameters.first;
        }
        if (requestParameters.max !== undefined) {
            queryParameters['max'] = requestParameters.max;
        }
        const headerParameters: runtime.HTTPHeaders = {};
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["manager", "driver", "employee"]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user-management/v1/employees/{employeeId}/timeEntries`.replace(`{${"employeeId"}}`, encodeURIComponent(String(requestParameters.employeeId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TimeEntryFromJSON));
    }
    /**
     * Lists Employees Time Entries. Sort by start time, latest first.
     * List Employees Time Entries.
     */
    async listEmployeeTimeEntries(requestParameters: ListEmployeeTimeEntriesRequest): Promise<Array<TimeEntry>> {
        const response = await this.listEmployeeTimeEntriesRaw(requestParameters);
        return await response.value();
    }
    /**
     * Lists Employees Time Entries. Sort by start time, latest first.
     * List Employees Time Entries.
     */
    async listEmployeeTimeEntriesWithHeaders(requestParameters: ListEmployeeTimeEntriesRequest): Promise<[ Array<TimeEntry>, Headers ]> {
        const response = await this.listEmployeeTimeEntriesRaw(requestParameters);
        const value = await response.value(); 
        return [ value, response.raw.headers ];
    }
    /**
     * Updates Employee\'s Time Entry.  Update should fail, when: 1) Modified entry does not have endTime but there is already another entry without endTime present in the system for same employee.  This is because time entries without endTime are considered to be running timers and only one is allowed at a time. 2) If modifying the entry would lead it to intersect with another time entry. 
     * Update Employee\'s Time Entry.
     */
    async updateEmployeeTimeEntryRaw(requestParameters: UpdateEmployeeTimeEntryRequest): Promise<runtime.ApiResponse<TimeEntry>> {
        if (requestParameters.timeEntry === null || requestParameters.timeEntry === undefined) {
            throw new runtime.RequiredError('timeEntry','Required parameter requestParameters.timeEntry was null or undefined when calling updateEmployeeTimeEntry.');
        }
        if (requestParameters.employeeId === null || requestParameters.employeeId === undefined) {
            throw new runtime.RequiredError('employeeId','Required parameter requestParameters.employeeId was null or undefined when calling updateEmployeeTimeEntry.');
        }
        if (requestParameters.timeEntryId === null || requestParameters.timeEntryId === undefined) {
            throw new runtime.RequiredError('timeEntryId','Required parameter requestParameters.timeEntryId was null or undefined when calling updateEmployeeTimeEntry.');
        }
        const queryParameters: any = {};
        const headerParameters: runtime.HTTPHeaders = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["manager", "employee"]);
            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/user-management/v1/employees/{employeeId}/timeEntries/{timeEntryId}`.replace(`{${"employeeId"}}`, encodeURIComponent(String(requestParameters.employeeId))).replace(`{${"timeEntryId"}}`, encodeURIComponent(String(requestParameters.timeEntryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TimeEntryToJSON(requestParameters.timeEntry),
        });
        return new runtime.JSONApiResponse(response, (jsonValue) => TimeEntryFromJSON(jsonValue));
    }
    /**
     * Updates Employee\'s Time Entry.  Update should fail, when: 1) Modified entry does not have endTime but there is already another entry without endTime present in the system for same employee.  This is because time entries without endTime are considered to be running timers and only one is allowed at a time. 2) If modifying the entry would lead it to intersect with another time entry. 
     * Update Employee\'s Time Entry.
     */
    async updateEmployeeTimeEntry(requestParameters: UpdateEmployeeTimeEntryRequest): Promise<TimeEntry> {
        const response = await this.updateEmployeeTimeEntryRaw(requestParameters);
        return await response.value();
    }
    /**
     * Updates Employee\'s Time Entry.  Update should fail, when: 1) Modified entry does not have endTime but there is already another entry without endTime present in the system for same employee.  This is because time entries without endTime are considered to be running timers and only one is allowed at a time. 2) If modifying the entry would lead it to intersect with another time entry. 
     * Update Employee\'s Time Entry.
     */
    async updateEmployeeTimeEntryWithHeaders(requestParameters: UpdateEmployeeTimeEntryRequest): Promise<[ TimeEntry, Headers ]> {
        const response = await this.updateEmployeeTimeEntryRaw(requestParameters);
        const value = await response.value(); 
        return [ value, response.raw.headers ];
    }
}
